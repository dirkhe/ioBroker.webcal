{
  "version": 3,
  "sources": ["../../src/lib/google.ts"],
  "sourcesContent": ["import { calendar, calendar_v3 } from \"@googleapis/calendar\";\nimport { auth as googleAuth, GaxiosPromise } from \"@googleapis/oauth2\";\nimport { AdapterInstance } from \"@iobroker/adapter-core\";\nimport { CalendarEvent, ICalendarTimeRangObj } from \"./calendarManager\";\n//const scope = \"https://www.googleapis.com/auth/calendar\";\n\nlet adapter: AdapterInstance;\nlet localTimeZone: string;\nexport function initLib(adapterInstance: AdapterInstance, adapterLocalTimeZone: string): void {\n\tadapter = adapterInstance;\n\tlocalTimeZone = adapterLocalTimeZone;\n}\n\nexport class GoogleCalendarEvent extends CalendarEvent {\n\tgoogleEvent: calendar_v3.Schema$Event | null;\n\tconstructor(googleEvent: calendar_v3.Schema$Event, startDate: Date, endDate: Date) {\n\t\tsuper(endDate);\n\t\tthis.googleEvent = googleEvent;\n\t\ttry {\n\t\t\tthis.summary = googleEvent.summary || \"\";\n\t\t\tthis.description = googleEvent.description || \"\";\n\t\t} catch (error) {\n\t\t\tadapter.log.error(\"could not read calendar Event: \" + error);\n\t\t\tadapter.log.debug(JSON.stringify(googleEvent));\n\t\t\tthis.googleEvent = null;\n\t\t}\n\t}\n\tgetNextTimeObj(isFirstCall: boolean): ICalendarTimeRangObj | null {\n\t\tif (!this.googleEvent || !isFirstCall) {\n\t\t\treturn null;\n\t\t}\n\t\tlet start: Date;\n\t\tlet end: Date;\n\t\tif (this.googleEvent.start) {\n\t\t\tif (this.googleEvent.start.date) {\n\t\t\t\tstart = new Date(this.googleEvent.start.date + \"T00:00\");\n\t\t\t} else {\n\t\t\t\tstart = new Date(this.googleEvent.start.dateTime || \"\");\n\t\t\t}\n\t\t} else {\n\t\t\tstart = new Date();\n\t\t}\n\t\tif (this.googleEvent.end) {\n\t\t\tif (this.googleEvent.end.date) {\n\t\t\t\tend = new Date(this.googleEvent.end.date + \"T23:59\");\n\t\t\t} else {\n\t\t\t\tend = new Date(this.googleEvent.end.dateTime || \"\");\n\t\t\t}\n\t\t} else {\n\t\t\tend = new Date();\n\t\t}\n\t\treturn {\n\t\t\tstartDate: start,\n\t\t\tendDate: end,\n\t\t};\n\t}\n}\n\nexport class GoogleCalendar implements webcal.ICalendarBase {\n\tclient: calendar_v3.Calendar;\n\tauth;\n\tcalendarId: string | undefined;\n\tname: string;\n\n\tconstructor(calConfig: webcal.IConfigCalendar) {\n\t\tthis.name = calConfig.name;\n\t\tthis.auth = new googleAuth.OAuth2(calConfig.clientId, calConfig.password);\n\t\tthis.auth.setCredentials({\n\t\t\trefresh_token: calConfig.refreshToken,\n\t\t});\n\t\tthis.client = calendar({\n\t\t\tversion: \"v3\",\n\t\t\tauth: this.auth,\n\t\t});\n\t}\n\n\t/**\n\t * load Calendars from Server\n\t * @param displayName if set, try to return Calendar with this name\n\t * @returns Calender by displaName or primary Calendar\n\t */\n\tprivate async getCalendar(displayName?: string): Promise<string> {\n\t\tif (!this.calendarId) {\n\t\t\tconst res = await this.client.calendarList.list();\n\t\t\tif (res && res.data && res.data.items) {\n\t\t\t\tconst calendars = res.data.items;\n\t\t\t\t//console.log(calendars)\n\t\t\t\tif (!displayName) {\n\t\t\t\t\tdisplayName = this.name;\n\t\t\t\t}\n\n\t\t\t\tif (displayName) {\n\t\t\t\t\tconst displayNameLowerCase = displayName.toLocaleLowerCase();\n\n\t\t\t\t\tfor (let i = 0; i < calendars.length; i++) {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tcalendars[i].summary?.toLowerCase() == displayNameLowerCase ||\n\t\t\t\t\t\t\tcalendars[i].summaryOverride?.toLowerCase() == displayNameLowerCase\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tthis.calendarId = calendars[i].id || \"\";\n\t\t\t\t\t\t\treturn this.calendarId;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tfor (let i = 0; i < calendars.length; i++) {\n\t\t\t\t\tif (calendars[i].primary) {\n\t\t\t\t\t\tthis.calendarId = calendars[i].id || \"\";\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this.calendarId || \"\";\n\t}\n\n\t/**\n\t * fetch Events form Calendar\n\t * @param startDate as date object\n\t * @param endDate as date object\n\t * @returns Array of Calenderobjects\n\t */\n\tprivate async getCalendarObjects(\n\t\tstartDateISOString: string,\n\t\tendDateISOString: string,\n\t): GaxiosPromise<calendar_v3.Schema$Events> {\n\t\tconst searchParams: any = {\n\t\t\tcalendarId: await this.getCalendar(),\n\t\t\tsingleEvents: true,\n\t\t\torderBy: \"startTime\",\n\t\t\ttimeZone: localTimeZone,\n\t\t};\n\t\tif (startDateISOString) {\n\t\t\tsearchParams.timeMin = startDateISOString;\n\t\t\tsearchParams.timeMax = endDateISOString;\n\t\t}\n\t\treturn this.client.events.list(searchParams);\n\t}\n\n\tloadEvents(calEvents: webcal.ICalendarEventBase[], startDate: Date, endDate: Date): Promise<string | null> {\n\t\treturn this.getCalendarObjects(startDate.toISOString(), endDate.toISOString())\n\t\t\t.then((res) => {\n\t\t\t\tconst calendarObjects = res?.data?.items;\n\t\t\t\tif (calendarObjects) {\n\t\t\t\t\tadapter.log.info(\"found \" + calendarObjects.length + \" calendar objects\");\n\t\t\t\t\tfor (const i in calendarObjects) {\n\t\t\t\t\t\tcalEvents.push(new GoogleCalendarEvent(calendarObjects[i], startDate, endDate));\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn null;\n\t\t\t})\n\t\t\t.catch((reason) => {\n\t\t\t\treturn reason.message;\n\t\t\t});\n\t}\n\tasync addEvent(calEvent: webcal.ICalendarEventData): Promise<any> {\n\t\tlet result;\n\t\ttry {\n\t\t\tconst start =\n\t\t\t\ttypeof calEvent.startDate == \"string\"\n\t\t\t\t\t? calEvent.startDate\n\t\t\t\t\t: CalendarEvent.getDateTimeISOStringFromEventDateTime(calEvent.startDate);\n\t\t\tconst data: calendar_v3.Schema$Event = {\n\t\t\t\tsummary: calEvent.summary,\n\t\t\t\tdescription: \"ioBroker webCal\",\n\t\t\t};\n\t\t\tif (start.length > 10) {\n\t\t\t\tdata.start = { dateTime: start, timeZone: localTimeZone };\n\t\t\t} else {\n\t\t\t\tdata.start = { date: start };\n\t\t\t}\n\t\t\tif (calEvent.endDate) {\n\t\t\t\tconst end =\n\t\t\t\t\ttypeof calEvent.endDate == \"string\"\n\t\t\t\t\t\t? calEvent.endDate\n\t\t\t\t\t\t: CalendarEvent.getDateTimeISOStringFromEventDateTime(calEvent.endDate);\n\t\t\t\tif (end.length > 10) {\n\t\t\t\t\tdata.end = { dateTime: end, timeZone: localTimeZone };\n\t\t\t\t} else {\n\t\t\t\t\tdata.end = { date: end };\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tdata.end = data.start;\n\t\t\t}\n\n\t\t\tconst res = await this.client.events.insert({\n\t\t\t\tcalendarId: await this.getCalendar(),\n\t\t\t\trequestBody: data,\n\t\t\t});\n\t\t\tresult = {\n\t\t\t\tok: !!res.data,\n\t\t\t\tmessage: res.statusText,\n\t\t\t};\n\t\t} catch (error) {\n\t\t\tresult = {\n\t\t\t\tok: false,\n\t\t\t\tmessage: (error as { message: string }).message,\n\t\t\t};\n\t\t}\n\n\t\t//console.log(result);\n\t\t//console.log(result.ok);\n\t\treturn result;\n\t}\n}\n"],
  "mappings": "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",
  "names": ["googleAuth"]
}
